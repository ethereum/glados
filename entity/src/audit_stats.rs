//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.13

use chrono::{TimeDelta, Utc};
use sea_orm::{entity::prelude::*, FromQueryResult, NotSet, QueryOrder, QuerySelect, Set};
use serde::Serialize;

#[derive(Clone, Debug, DeriveEntityModel, Serialize)]
#[sea_orm(table_name = "audit_stats")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub timestamp: DateTimeUtc,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_all: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_sync: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_random: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_all_bodies: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_sync_bodies: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_random_bodies: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_all_receipts: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_sync_receipts: f32,
    #[sea_orm(column_type = "Float")]
    pub success_rate_history_random_receipts: f32,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

// *** Custom additions ***

#[allow(clippy::too_many_arguments)]
pub async fn create(
    timestamp: DateTimeUtc,
    success_rate_history_all: f32,
    success_rate_history_sync: f32,
    success_rate_history_random: f32,
    success_rate_history_all_bodies: f32,
    success_rate_history_sync_bodies: f32,
    success_rate_history_random_bodies: f32,
    success_rate_history_all_receipts: f32,
    success_rate_history_sync_receipts: f32,
    success_rate_history_random_receipts: f32,
    conn: &DatabaseConnection,
) -> Result<Model, DbErr> {
    let audit_stats = ActiveModel {
        id: NotSet,
        timestamp: Set(timestamp),
        success_rate_history_all: Set(success_rate_history_all),
        success_rate_history_sync: Set(success_rate_history_sync),
        success_rate_history_random: Set(success_rate_history_random),
        success_rate_history_all_bodies: Set(success_rate_history_all_bodies),
        success_rate_history_sync_bodies: Set(success_rate_history_sync_bodies),
        success_rate_history_random_bodies: Set(success_rate_history_random_bodies),
        success_rate_history_all_receipts: Set(success_rate_history_all_receipts),
        success_rate_history_sync_receipts: Set(success_rate_history_sync_receipts),
        success_rate_history_random_receipts: Set(success_rate_history_random_receipts),
    };
    audit_stats.insert(conn).await
}

// Separate per subprotocol for future use cases

// *** History ***

#[derive(Clone, Debug, Serialize, FromQueryResult)]
pub struct HistoryStats {
    id: i32,
    timestamp: DateTimeUtc,
    success_rate_history_all: f32,
    success_rate_history_sync: f32,
    success_rate_history_random: f32,
    success_rate_history_all_bodies: f32,
    success_rate_history_sync_bodies: f32,
    success_rate_history_random_bodies: f32,
    success_rate_history_all_receipts: f32,
    success_rate_history_sync_receipts: f32,
    success_rate_history_random_receipts: f32,
}

// Get 7 days of history audit stat series.
pub async fn get_weekly_history_stats(
    conn: &DatabaseConnection,
    weeks_ago: i32,
) -> Result<Vec<HistoryStats>, DbErr> {
    const WEEK: TimeDelta = TimeDelta::days(7);

    let beginning = Utc::now() - WEEK * weeks_ago;
    let end = beginning + WEEK;

    Entity::find()
        .select_only()
        .columns([
            Column::Id,
            Column::Timestamp,
            Column::SuccessRateHistoryAll,
            Column::SuccessRateHistorySync,
            Column::SuccessRateHistoryRandom,
            Column::SuccessRateHistoryAllBodies,
            Column::SuccessRateHistoryAllReceipts,
            Column::SuccessRateHistorySyncBodies,
            Column::SuccessRateHistorySyncReceipts,
            Column::SuccessRateHistoryRandomBodies,
            Column::SuccessRateHistoryRandomReceipts,
        ])
        .filter(Column::Timestamp.gt(beginning))
        .filter(Column::Timestamp.lt(end))
        .order_by_asc(Column::Timestamp)
        .into_model::<HistoryStats>()
        .all(conn)
        .await
}
