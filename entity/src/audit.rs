//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.13

use chrono::Utc;
use ethportal_api::OverlayContentKey;
use sea_orm::{entity::prelude::*, DbBackend, FromQueryResult, NotSet, QueryOrder, Set, Statement};

use crate::{audit_latest, content, utils, AuditResult, SelectionStrategy};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "audit")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub content_id: i32,
    pub client_id: i32,
    pub node_id: i32,
    pub strategy: SelectionStrategy,
    pub result: AuditResult,
    pub created_at: DateTimeUtc,
    #[sea_orm(column_type = "Text", nullable)]
    pub trace: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_one = "super::audit_latest::Entity")]
    AuditLatest,
    #[sea_orm(has_many = "super::audit_transfer_failure::Entity")]
    AuditTransferFailure,
    #[sea_orm(
        belongs_to = "super::client::Entity",
        from = "Column::ClientId",
        to = "super::client::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Client,
    #[sea_orm(
        belongs_to = "super::content::Entity",
        from = "Column::ContentId",
        to = "super::content::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Content,
    #[sea_orm(
        belongs_to = "super::node::Entity",
        from = "Column::NodeId",
        to = "super::node::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Node,
}

impl Related<super::audit_latest::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AuditLatest.def()
    }
}

impl Related<super::audit_transfer_failure::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AuditTransferFailure.def()
    }
}

impl Related<super::client::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Client.def()
    }
}

impl Related<super::content::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Content.def()
    }
}

impl Related<super::node::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Node.def()
    }
}

#[async_trait::async_trait]
impl ActiveModelBehavior for ActiveModel {
    async fn after_save<C>(model: Model, db: &C, _insert: bool) -> Result<Model, DbErr>
    where
        C: ConnectionTrait,
    {
        audit_latest::create(&model, db).await?;
        Ok(model)
    }
}

// *** Custom additions ***

impl Model {
    pub fn is_success(&self) -> bool {
        self.result == AuditResult::Success
    }

    pub fn created_at_local_time(&self) -> String {
        self.created_at.with_timezone(&chrono::Local).to_rfc2822()
    }

    pub fn created_at_humanized(&self) -> String {
        utils::time_ago(self.created_at, Utc::now())
    }

    pub fn trace_as_html(&self) -> String {
        match &self.trace {
            Some(trace) => trace.to_string(),
            None => "{}".to_string(),
        }
    }
}

pub async fn create(
    content_id: i32,
    client_id: i32,
    node_id: i32,
    audit_result: AuditResult,
    strategy: SelectionStrategy,
    trace: Option<String>,
    conn: &DatabaseConnection,
) -> Result<Model, DbErr> {
    // If no record exists, create one and return it
    let content_audit = ActiveModel {
        id: NotSet,
        content_id: Set(content_id),
        client_id: Set(client_id),
        node_id: Set(node_id),
        strategy: Set(strategy),
        result: Set(audit_result),
        created_at: Set(Utc::now()),
        trace: Set(trace),
    };
    content_audit.insert(conn).await
}

pub async fn get_audits<T: OverlayContentKey>(
    content_key: &T,
    conn: &DatabaseConnection,
) -> Result<Vec<Model>, DbErr> {
    let Some(content_model) = content::get(content_key, conn).await? else {
        return Err(DbErr::RecordNotFound(format!(
            "Expected stored content_key found none: {}",
            content_key
        )));
    };
    Entity::find()
        .filter(Column::ContentId.eq(content_model.id))
        .all(conn)
        .await
}

pub async fn get_latest_audit(
    strategy: SelectionStrategy,
    conn: &DatabaseConnection,
) -> Result<Option<Model>, DbErr> {
    Entity::find()
        .filter(Column::Strategy.eq(strategy))
        .order_by_desc(Column::Id)
        .one(conn)
        .await
}

#[derive(FromQueryResult)]
pub struct FailedKeysResult {
    pub content_key: Vec<u8>,
}

pub async fn get_failed_keys(
    strategy: SelectionStrategy,
    page: u32,
    conn: &DatabaseConnection,
) -> anyhow::Result<Vec<FailedKeysResult>> {
    const PAGE_SIZE: u32 = 1000;

    Ok(
        FailedKeysResult::find_by_statement(Statement::from_sql_and_values(
            DbBackend::Postgres,
            "
            SELECT
                content.content_key
            FROM audit
            INNER JOIN content ON content.id = audit.content_id
            WHERE
                audit.result = 0 AND
                audit.strategy = $1
            GROUP BY content.content_key
            ORDER BY MAX(audit.created_at) DESC
            LIMIT $2
            OFFSET $3
            ",
            vec![
                strategy.into(),
                PAGE_SIZE.into(),
                ((page - 1) * PAGE_SIZE).into(),
            ],
        ))
        .all(conn)
        .await?,
    )
}

#[cfg(test)]
mod tests {
    use enr::NodeId;
    use ethportal_api::HistoryContentKey;

    use crate::{client, node, test_utils::setup_database, HistorySelectionStrategy, SubProtocol};

    use super::*;

    #[tokio::test]
    async fn crud() -> anyhow::Result<()> {
        let (conn, _db) = setup_database().await?;

        let block_number = 12_345_678;
        let key = HistoryContentKey::new_block_header_by_number(block_number);

        let content_model =
            content::get_or_create(SubProtocol::History, &key, Some(block_number), &conn).await?;
        assert_eq!(content_model.content_id, key.content_id());
        assert_eq!(content_model.content_key, key.to_bytes());

        let client_model = client::get_or_create("trin v0.1.0".to_string(), &conn).await?;
        let node_model = node::get_or_create(NodeId::random(), &conn).await.unwrap();

        let created_audit_model = create(
            content_model.id,
            client_model.id,
            node_model.id,
            AuditResult::Success,
            SelectionStrategy::History(HistorySelectionStrategy::Random),
            None,
            &conn,
        )
        .await?;

        assert_eq!(created_audit_model.content_id, content_model.id);
        assert_eq!(created_audit_model.result, AuditResult::Success);
        assert_eq!(
            created_audit_model.strategy,
            SelectionStrategy::History(HistorySelectionStrategy::Random),
        );

        let searched_audit_model = Entity::find_by_id(created_audit_model.id)
            .one(&conn)
            .await?
            .unwrap();
        assert_eq!(searched_audit_model.content_id, content_model.id);
        assert_eq!(searched_audit_model.result, AuditResult::Success);
        assert_eq!(
            created_audit_model.strategy,
            SelectionStrategy::History(HistorySelectionStrategy::Random),
        );

        Ok(())
    }

    #[tokio::test]
    async fn audit_latest() -> anyhow::Result<()> {
        let (conn, _db) = setup_database().await?;

        let block_number = 12_345_678;
        let key = HistoryContentKey::new_block_header_by_number(block_number);

        let content =
            content::get_or_create(SubProtocol::History, &key, Some(block_number), &conn).await?;
        let client = client::get_or_create("trin v0.1.0".to_string(), &conn).await?;
        let node = node::get_or_create(NodeId::random(), &conn).await.unwrap();

        // Create audit and verify that audit_latest is created as well
        let audit_1 = create(
            content.id,
            client.id,
            node.id,
            AuditResult::Success,
            SelectionStrategy::History(HistorySelectionStrategy::Random),
            None,
            &conn,
        )
        .await?;
        assert_eq!(
            audit_latest::Entity::find_by_id(content.id)
                .one(&conn)
                .await?,
            Some(audit_latest::Model {
                content_id: content.id,
                audit_id: audit_1.id,
            }),
        );

        // Create another audit and verify that audit_latest is updated
        let audit_2 = create(
            content.id,
            client.id,
            node.id,
            AuditResult::Success,
            SelectionStrategy::History(HistorySelectionStrategy::Random),
            None,
            &conn,
        )
        .await?;
        assert_ne!(audit_1.id, audit_2.id); // Check that it's new audit
        assert_eq!(
            audit_latest::Entity::find_by_id(content.id)
                .one(&conn)
                .await?,
            Some(audit_latest::Model {
                content_id: content.id,
                audit_id: audit_2.id,
            }),
        );

        Ok(())
    }
}
