//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.13

use std::collections::HashMap;

use alloy_primitives::U256;
use enr::NodeId;
use ethportal_api::utils::bytes::hex_encode;
use sea_orm::{
    entity::prelude::*, sea_query::Expr, FromQueryResult, NotSet, QueryOrder, QuerySelect, Set,
};

use lazy_static::lazy_static;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "node")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "VarBinary(StringLen::N(32))", unique)]
    pub node_id: Vec<u8>,
    pub node_id_high: i64,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::audit::Entity")]
    Audit,
    #[sea_orm(has_many = "super::node_enr::Entity")]
    NodeEnr,
}

impl Related<super::audit::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Audit.def()
    }
}

impl Related<super::node_enr::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::NodeEnr.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

// *** Custom additions ***

impl Model {
    pub fn node_id_as_hex(&self) -> String {
        hex_encode(&self.node_id)
    }

    pub fn get_node_id(&self) -> NodeId {
        let mut node_id = [0u8; 32];
        node_id.copy_from_slice(&self.node_id);
        NodeId::new(&node_id)
    }

    pub fn get_nickname(&self) -> Option<String> {
        NODE_NICKNAME_MAP.get(&self.node_id_as_hex()).cloned()
    }
}

#[derive(FromQueryResult)]
pub struct ModelWithDistance {
    pub id: i32,
    pub node_id: Vec<u8>,
    pub node_id_high: i64,
    pub distance: i64,
}

impl ModelWithDistance {
    pub fn node_id_as_hex(&self) -> String {
        hex_encode(&self.node_id)
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
enum ComputedColumn {
    Distance,
}

impl ColumnTrait for ComputedColumn {
    type EntityName = Entity;

    fn def(&self) -> ColumnDef {
        match self {
            Self::Distance => ColumnType::Integer.def(),
        }
    }
}

pub async fn closest_xor(
    node_id: NodeId,
    conn: &DatabaseConnection,
) -> Result<Vec<ModelWithDistance>, DbErr> {
    let raw_node_id = U256::from_be_slice(&node_id.raw());
    let node_id_high: i64 = raw_node_id.wrapping_shr(193).to::<i64>();

    let distance_expression = Expr::cust_with_values(
        "(\"node\".\"node_id_high\" | $1) - (\"node\".\"node_id_high\" & $2)",
        [node_id_high, node_id_high],
    );

    Entity::find()
        .column_as(distance_expression, "distance")
        .order_by_asc(Expr::col(ComputedColumn::Distance))
        .limit(100)
        .into_model::<ModelWithDistance>()
        .all(conn)
        .await
}

pub async fn get_or_create(node_id: NodeId, conn: &DatabaseConnection) -> Result<Model, DbErr> {
    // First try to lookup an existing entry.
    if let Some(node_id_model) = Entity::find()
        .filter(Column::NodeId.eq(node_id.raw().to_vec()))
        .one(conn)
        .await?
    {
        // If there is an existing record, return it
        return Ok(node_id_model);
    }

    // If no record exists, create one and return it
    let raw_node_id = U256::from_be_slice(&node_id.raw());
    let node_id_high: i64 = raw_node_id.wrapping_shr(193).to::<i64>();

    let node_id_model = ActiveModel {
        id: NotSet,
        node_id: Set(node_id.raw().into()),
        node_id_high: Set(node_id_high),
    };

    node_id_model.insert(conn).await
}

lazy_static! {
    pub static ref NODE_NICKNAME_MAP: HashMap<String, String> = {
        let mut nicknames = HashMap::<String, String>::new();

        nicknames.insert(
            "0x0000240180d81307b438e3a6d93d3ed9d486cae8525e97721c823a40f3294acf".to_string(),
            "nimbus-ih-eu-mda1-01-01 (bootnode)".to_string(),
        );
        nicknames.insert(
            "0x04001b85919f3d5b3f6f1f43f2abdf08252e8e5a54eb3a43a0cee1396ae77127".to_string(),
            "nimbus-ih-eu-mda1-01-02 (bootnode)".to_string(),
        );
        nicknames.insert(
            "0x8000a4aa5ddc53d2892b7920a4a562c0375cb86d760c3e272a5f72de0f3b612c".to_string(),
            "nimbus-ih-eu-mda1-02-01 (bootnode)".to_string(),
        );
        nicknames.insert(
            "0x8400220fe8fff199b2e4b85a17830a36523c8dd7bb7835902b1f78c06b23d7f8".to_string(),
            "nimbus-ih-eu-mda1-02-02 (bootnode)".to_string(),
        );

        nicknames
    };
    pub static ref BOOTNODE_NICKNAMES: HashMap<String, String> = {
        NODE_NICKNAME_MAP
            .iter()
            .filter(|(_, nickname)| nickname.contains("bootnode"))
            .map(|(id, nickname)| (id.clone(), nickname.clone()))
            .collect()
    };
}

#[cfg(test)]
mod tests {
    use crate::test_utils::setup_database;

    use super::*;

    #[tokio::test]
    async fn crud() -> Result<(), DbErr> {
        let (conn, _db) = setup_database().await?;

        let node_id_a: Vec<u8> = vec![
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31,
        ];
        let node_id_b: Vec<u8> = vec![
            31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10,
            9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
        ];

        let node_a = ActiveModel {
            id: NotSet,
            node_id: Set(node_id_a.clone()),
            node_id_high: Set(0),
        };
        let node_b = ActiveModel {
            id: NotSet,
            node_id: Set(node_id_b.clone()),
            node_id_high: Set(0),
        };

        assert_eq!(Entity::find().count(&conn).await?, 0);

        let node_a = node_a.insert(&conn).await?;
        println!("Inserted: node_a={:?}", node_a);

        let node_b = node_b.insert(&conn).await?;
        println!("Inserted: node_b={:?}", node_b);

        assert_eq!(Entity::find().count(&conn).await?, 2);

        let node_a = Entity::find()
            .filter(Column::NodeId.eq(node_id_a.clone()))
            .one(&conn)
            .await?
            .unwrap();

        assert_eq!(node_a.node_id, node_id_a);

        let node_b = Entity::find()
            .filter(Column::NodeId.eq(node_id_b.clone()))
            .one(&conn)
            .await?
            .unwrap();

        assert_eq!(node_b.node_id, node_id_b);

        Ok(())
    }

    #[tokio::test]
    async fn query_closest() {
        use env_logger;
        env_logger::init();
        let (conn, _db) = setup_database().await.unwrap();

        let node_id_a = NodeId::random();
        let node_id_b = NodeId::random();
        let node_id_c = NodeId::random();

        let node_a = get_or_create(node_id_a, &conn).await.unwrap();
        let node_b = get_or_create(node_id_b, &conn).await.unwrap();
        let node_c = get_or_create(node_id_c, &conn).await.unwrap();

        let distance_a_b = node_a.node_id_high ^ node_b.node_id_high;
        let distance_a_c = node_a.node_id_high ^ node_c.node_id_high;
        let distance_b_c = node_b.node_id_high ^ node_c.node_id_high;

        let node_id_a_full = U256::from_be_slice(&node_id_a.raw());
        let node_id_b_full = U256::from_be_slice(&node_id_b.raw());
        let node_id_c_full = U256::from_be_slice(&node_id_c.raw());

        assert_eq!(
            node_a.node_id_high as u64,
            node_id_a_full.wrapping_shr(193).to::<u64>()
        );
        assert_eq!(
            node_b.node_id_high as u64,
            node_id_b_full.wrapping_shr(193).to::<u64>()
        );
        assert_eq!(
            node_c.node_id_high as u64,
            node_id_c_full.wrapping_shr(193).to::<u64>()
        );

        let distance_a_b_full = node_id_a_full ^ node_id_b_full;
        let distance_a_c_full = node_id_a_full ^ node_id_c_full;
        let distance_b_c_full = node_id_b_full ^ node_id_c_full;

        //let distance_a_b_alt = (node_id_a_full | node_id_b_full) - (node_id_a_full & node_id_b_full);

        assert_eq!(
            distance_a_b_full.wrapping_shr(193).to::<u64>(),
            distance_a_b as u64
        );
        assert_eq!(
            distance_a_c_full.wrapping_shr(193).to::<u64>(),
            distance_a_c as u64
        );
        assert_eq!(
            distance_b_c_full.wrapping_shr(193).to::<u64>(),
            distance_b_c as u64
        );

        assert_eq!(
            distance_a_b_full > distance_a_c_full,
            distance_a_b > distance_a_c
        );
        assert_eq!(
            distance_a_c_full > distance_b_c_full,
            distance_a_c > distance_b_c
        );
        assert_eq!(
            distance_a_b_full > distance_b_c_full,
            distance_a_b > distance_b_c
        );

        let nodes_near_a = closest_xor(node_id_a, &conn).await.unwrap();
        assert_eq!(nodes_near_a.len(), 3);

        let expected_distances_a = match distance_a_b > distance_a_c {
            true => [0, distance_a_c, distance_a_b],
            false => [0, distance_a_b, distance_a_c],
        };
        let actual_distances_a = [
            nodes_near_a[0].distance,
            nodes_near_a[1].distance,
            nodes_near_a[2].distance,
        ];
        assert_eq!(expected_distances_a, actual_distances_a);

        let expected_from_a = match distance_a_b > distance_a_c {
            true => [node_a.id, node_c.id, node_b.id],
            false => [node_a.id, node_b.id, node_c.id],
        };
        let order_from_a = [nodes_near_a[0].id, nodes_near_a[1].id, nodes_near_a[2].id];
        assert_eq!(order_from_a, expected_from_a);

        let nodes_near_b = closest_xor(node_id_b, &conn).await.unwrap();
        let expected_from_b = match distance_a_b > distance_b_c {
            true => [node_b.id, node_c.id, node_a.id],
            false => [node_b.id, node_a.id, node_c.id],
        };
        let order_from_b = [nodes_near_b[0].id, nodes_near_b[1].id, nodes_near_b[2].id];
        assert_eq!(order_from_b, expected_from_b);

        let nodes_near_c = closest_xor(node_id_c, &conn).await.unwrap();
        let expected_from_c = match distance_a_c > distance_b_c {
            true => [node_c.id, node_b.id, node_a.id],
            false => [node_c.id, node_a.id, node_b.id],
        };
        let order_from_c = [nodes_near_c[0].id, nodes_near_c[1].id, nodes_near_c[2].id];
        assert_eq!(order_from_c, expected_from_c);
    }
}
