//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.7
use std::fmt;

use anyhow::{bail, Result};
use chrono::{DateTime, Utc};
use clap::ValueEnum;
use content::SubProtocol;
use ethportal_api::{utils::bytes::hex_encode, OverlayContentKey};
use sea_orm::{
    entity::prelude::*,
    strum::{EnumMessage, EnumString, IntoEnumIterator},
    ActiveValue::NotSet,
    DbBackend, DeriveActiveEnum, FromQueryResult, Set, Statement, TryGetable,
};
use sea_query::{ArrayType, Nullable, SeaRc, ValueType, ValueTypeErr};
use serde::{Deserialize, Serialize};

use crate::content;
use crate::utils;

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    EnumIter,
    EnumMessage,
    EnumString,
    DeriveActiveEnum,
    Copy,
    Deserialize,
    Serialize,
)]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case", ascii_case_insensitive)]
#[sea_orm(rs_type = "i32", db_type = "Integer")]
pub enum AuditResult {
    #[strum(message = "Failure")]
    Failure = 0,
    #[strum(message = "Success")]
    Success = 1,
}

#[derive(
    Debug,
    Clone,
    Eq,
    Hash,
    PartialEq,
    EnumIter,
    EnumMessage,
    EnumString,
    DeriveActiveEnum,
    ValueEnum,
    Serialize,
    Deserialize,
    Copy,
)]
#[clap(rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case", ascii_case_insensitive)]
#[sea_orm(rs_type = "i32", db_type = "Integer")]
/// Each strategy is responsible for selecting which content key(s) to begin audits for.
pub enum HistorySelectionStrategy {
    /// Content that is:
    /// 1. Not yet audited
    /// 2. Sorted by date entered into glados database (newest first).
    #[strum(message = "Latest", props(subprotocol = "0"))]
    Latest = 0,
    /// Randomly selected content.
    #[strum(message = "Random", props(subprotocol = "0"))]
    Random = 1,
    /// Content that looks for failed audits and checks whether the data is still missing.
    /// 1. Key was audited previously
    /// 2. Latest audit for the key failed (data absent)
    /// 3. Keys sorted by date audited (keys with oldest failed audit first)
    #[strum(message = "Failed", props(subprotocol = "0"))]
    Failed = 2,
    /// Content that is:
    /// 1. Not yet audited.
    /// 2. Sorted by date entered into glados database (oldest first).
    #[strum(message = "Oldest Unaudited", props(subprotocol = "0"))]
    OldestUnaudited = 3,
    /// Perform a single audit for a previously audited content key.
    #[strum(message = "Specific Content Key", props(subprotocol = "0"))]
    SpecificContentKey = 4,
    /// Perform audits of random fourfours data.
    #[strum(message = "Four Fours", props(subprotocol = "0"))]
    FourFours = 5,
}

impl From<i32> for HistorySelectionStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => HistorySelectionStrategy::Latest,
            1 => HistorySelectionStrategy::Random,
            2 => HistorySelectionStrategy::Failed,
            3 => HistorySelectionStrategy::OldestUnaudited,
            4 => HistorySelectionStrategy::SpecificContentKey,
            5 => HistorySelectionStrategy::FourFours,
            _ => panic!("Invalid value for HistorySelectionStrategy"),
        }
    }
}

#[derive(
    Debug,
    Clone,
    Eq,
    Hash,
    PartialEq,
    EnumIter,
    EnumMessage,
    EnumString,
    DeriveActiveEnum,
    ValueEnum,
    Serialize,
    Deserialize,
    Copy,
)]
#[clap(rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case", ascii_case_insensitive)]
#[sea_orm(rs_type = "i32", db_type = "Integer")]
/// Each strategy is responsible for selecting which content key(s) to begin audits for.
pub enum BeaconSelectionStrategy {
    /// Content that is:
    /// 1. Not yet audited
    /// 2. Sorted by date entered into glados database (newest first).
    #[strum(message = "Latest", props(subprotocol = "1"))]
    Latest = 0,
}

impl From<i32> for BeaconSelectionStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => BeaconSelectionStrategy::Latest,
            _ => panic!("Invalid value for BeaconSelectionStrategy"),
        }
    }
}

#[derive(
    Debug,
    Clone,
    Eq,
    Hash,
    PartialEq,
    EnumIter,
    EnumMessage,
    EnumString,
    DeriveActiveEnum,
    ValueEnum,
    Serialize,
    Deserialize,
    Copy,
)]
#[clap(rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
#[strum(serialize_all = "snake_case", ascii_case_insensitive)]
#[sea_orm(rs_type = "i32", db_type = "Integer")]
/// Each strategy is responsible for selecting which content key(s) to begin audits for.
pub enum StateSelectionStrategy {
    /// Does a random walk of the state at a random walk.
    #[strum(message = "State Roots", props(subprotocol = "2"))]
    StateRoots = 0,
}

impl From<i32> for StateSelectionStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => StateSelectionStrategy::StateRoots,
            _ => panic!("Invalid value for StateSelectionStrategy"),
        }
    }
}

#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SelectionStrategy {
    History(HistorySelectionStrategy),
    Beacon(BeaconSelectionStrategy),
    State(StateSelectionStrategy),
}

impl From<SelectionStrategy> for Value {
    fn from(value: SelectionStrategy) -> Self {
        match value {
            SelectionStrategy::History(h) => Value::Int(Some(h as i32)),
            SelectionStrategy::Beacon(b) => Value::Int(Some(0x10000 + b as i32)),
            SelectionStrategy::State(s) => Value::Int(Some(0x20000 + s as i32)),
        }
    }
}

impl Nullable for SelectionStrategy {
    fn null() -> Value {
        Value::Int(None)
    }
}

impl ValueType for SelectionStrategy {
    fn try_from(v: Value) -> Result<Self, ValueTypeErr> {
        match v {
            Value::Int(Some(value)) => match value >> 16 {
                0 => Ok(SelectionStrategy::History(HistorySelectionStrategy::from(
                    value & 0xFFFF,
                ))),
                1 => Ok(SelectionStrategy::Beacon(BeaconSelectionStrategy::from(
                    value & 0xFFFF,
                ))),
                2 => Ok(SelectionStrategy::State(StateSelectionStrategy::from(
                    value & 0xFFFF,
                ))),
                _ => Err(ValueTypeErr),
            },
            _ => Err(ValueTypeErr),
        }
    }

    fn type_name() -> String {
        stringify!(SelectionStrategy).to_owned()
    }

    fn array_type() -> ArrayType {
        ArrayType::Int
    }

    fn column_type() -> ColumnType {
        ColumnType::Integer
    }
}

impl IntoEnumIterator for SelectionStrategy {
    type Iterator = std::vec::IntoIter<Self>;

    fn iter() -> Self::Iterator {
        [
            HistorySelectionStrategy::iter()
                .map(SelectionStrategy::History)
                .collect::<Vec<_>>(),
            BeaconSelectionStrategy::iter()
                .map(SelectionStrategy::Beacon)
                .collect::<Vec<_>>(),
            StateSelectionStrategy::iter()
                .map(SelectionStrategy::State)
                .collect::<Vec<_>>(),
        ]
        .concat()
        .into_iter()
    }
}

#[derive(Debug, Iden)]
#[iden = "selection_strategy"]
pub struct SelectionStrategyEnum;

impl ActiveEnum for SelectionStrategy {
    type Value = i32;

    type ValueVec = Vec<Self::Value>;

    fn name() -> sea_orm::DynIden {
        SeaRc::new(SelectionStrategyEnum)
    }

    fn to_value(&self) -> Self::Value {
        match self {
            SelectionStrategy::History(h) => h.to_value(),
            SelectionStrategy::Beacon(b) => 0x10000 + b.to_value(),
            SelectionStrategy::State(s) => 0x20000 + s.to_value(),
        }
    }

    fn try_from_value(v: &Self::Value) -> std::prelude::v1::Result<Self, DbErr> {
        match v >> 16 {
            0 => Ok(SelectionStrategy::History(HistorySelectionStrategy::from(
                v & 0xFFFF,
            ))),
            1 => Ok(SelectionStrategy::Beacon(BeaconSelectionStrategy::from(
                v & 0xFFFF,
            ))),
            2 => Ok(SelectionStrategy::State(StateSelectionStrategy::from(
                v & 0xFFFF,
            ))),
            _ => Err(DbErr::Type(
                "Invalid value for SelectionStrategy".to_string(),
            )),
        }
    }

    fn db_type() -> ColumnDef {
        ColumnType::Integer.def()
    }
}

impl TryGetable for SelectionStrategy {
    fn try_get_by<I: sea_orm::ColIdx>(
        res: &QueryResult,
        index: I,
    ) -> std::prelude::v1::Result<Self, sea_orm::TryGetError> {
        let value = i32::try_get_by(res, index)?;
        SelectionStrategy::try_from_value(&value).map_err(|_| {
            sea_orm::TryGetError::DbErr(DbErr::Type(
                "Invalid value for SelectionStrategy".to_string(),
            ))
        })
    }
}

impl From<HistorySelectionStrategy> for SelectionStrategy {
    fn from(value: HistorySelectionStrategy) -> Self {
        Self::History(value)
    }
}

impl From<StateSelectionStrategy> for SelectionStrategy {
    fn from(value: StateSelectionStrategy) -> Self {
        Self::State(value)
    }
}

impl From<BeaconSelectionStrategy> for SelectionStrategy {
    fn from(value: BeaconSelectionStrategy) -> Self {
        Self::Beacon(value)
    }
}

impl SelectionStrategy {
    pub fn get_message(&self) -> Option<&str> {
        match self {
            SelectionStrategy::History(h) => h.get_message(),
            SelectionStrategy::Beacon(b) => b.get_message(),
            SelectionStrategy::State(s) => s.get_message(),
        }
    }
    pub fn get_serializations(&self) -> &[&str] {
        match self {
            SelectionStrategy::History(h) => h.get_serializations(),
            SelectionStrategy::Beacon(b) => b.get_serializations(),
            SelectionStrategy::State(s) => s.get_serializations(),
        }
    }
}

#[derive(FromQueryResult)]
struct FailedKeysResult {
    content_key: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "content_audit")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub content_key: i32,
    pub client_info: Option<i32>,
    pub node: Option<i32>,
    pub created_at: DateTime<Utc>,
    pub strategy_used: Option<SelectionStrategy>,
    pub result: AuditResult,
    pub trace: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::content::Entity",
        from = "Column::ContentKey",
        to = "super::content::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Content,
    #[sea_orm(
        belongs_to = "super::client_info::Entity",
        from = "Column::ClientInfo",
        to = "super::client_info::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    ClientInfo,
    #[sea_orm(
        belongs_to = "super::node::Entity",
        from = "Column::Node",
        to = "super::node::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Node,
}

impl Related<super::content::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Content.def()
    }
}

impl Related<super::client_info::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::ClientInfo.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub async fn create(
    content_key_model_id: i32,
    client_info_id: i32,
    node_id: i32,
    query_successful: bool,
    strategy_used: SelectionStrategy,
    trace_string: String,
    conn: &DatabaseConnection,
) -> Result<Model> {
    // If no record exists, create one and return it
    let audit_result = if query_successful {
        AuditResult::Success
    } else {
        AuditResult::Failure
    };

    let content_audit = ActiveModel {
        id: NotSet,
        content_key: Set(content_key_model_id),
        client_info: Set(Some(client_info_id)),
        node: Set(Some(node_id)),
        created_at: Set(Utc::now()),
        result: Set(audit_result),
        strategy_used: Set(Some(strategy_used)),
        trace: Set(trace_string),
    };
    Ok(content_audit.insert(conn).await?)
}

pub async fn get_audits<T: OverlayContentKey>(
    content_key: &T,
    conn: &DatabaseConnection,
) -> Result<Vec<Model>> {
    let Some(content_key_model) = content::get(content_key, conn).await? else {
        bail!("Expected stored content_key found none.")
    };
    Ok(Entity::find()
        .filter(Column::ContentKey.eq(content_key_model.id))
        .all(conn)
        .await?)
}

pub fn serialize_selection_strategy(
    network: SubProtocol,
    selection_strategy_str: &str,
) -> std::prelude::v1::Result<SelectionStrategy, String> {
    match network {
        SubProtocol::History => Ok(SelectionStrategy::History(
            HistorySelectionStrategy::from_str(selection_strategy_str, true)?,
        )),
        SubProtocol::State => Ok(SelectionStrategy::State(StateSelectionStrategy::from_str(
            selection_strategy_str,
            true,
        )?)),
        SubProtocol::Beacon => Ok(SelectionStrategy::Beacon(
            BeaconSelectionStrategy::from_str(selection_strategy_str, true)?,
        )),
    }
}

pub async fn get_failed_keys(
    subprotocol: SubProtocol,
    strategy_used: String,
    page: u32,
    conn: &DatabaseConnection,
) -> Result<Vec<String>> {
    const PAGE_SIZE: u32 = 1000;

    let subprotocol_strategy =
        serialize_selection_strategy(subprotocol, &strategy_used).map_err(|_| {
            anyhow::Error::msg(format!(
                "unknown variant for {}: {}",
                subprotocol, strategy_used
            ))
        })?;

    let keys_result = FailedKeysResult::find_by_statement(Statement::from_sql_and_values(
        DbBackend::Postgres,
        "
        SELECT
              content.content_key
        FROM content_audit
        INNER JOIN content ON content.id = content_audit.content_key
        WHERE
            content_audit.result = 0 AND
            content_audit.strategy_used = $1 AND
            content_audit.created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
        GROUP BY content.content_key
        ORDER BY MAX(content_audit.created_at) DESC
        LIMIT $2
        OFFSET $3
          content_key
        FROM (
          SELECT
            content.content_key,
            MAX(content_audit.created_at) AS created_at
          FROM content_audit
          JOIN content ON content.id = content_audit.content_key
          WHERE
            content_audit.result = 0  AND
            content_audit.strategy_used = $1 AND
            content_audit.created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
          GROUP BY content.content_key
        ) prep
        ORDER BY created_at DESC
        LIMIT $2
        OFFSET $3
        ",
        vec![
            subprotocol_strategy.into(),
            PAGE_SIZE.into(),
            ((page - 1) * PAGE_SIZE).into(),
        ],
    ))
    .all(conn)
    .await?;

    Ok(keys_result
        .into_iter()
        .map(|result_item| hex_encode(result_item.content_key))
        .collect::<Vec<String>>())
}

impl fmt::Display for SelectionStrategy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SelectionStrategy::History(h) => write!(
                f,
                "{}",
                h.get_message()
                    .expect("HistorySelectionStrategy missing message")
            ),
            SelectionStrategy::Beacon(b) => write!(
                f,
                "{}",
                b.get_message()
                    .expect("BeaconSelectionStrategy missing message")
            ),
            SelectionStrategy::State(s) => write!(
                f,
                "{}",
                s.get_message()
                    .expect("StateSelectionStrategy missing message")
            ),
        }
    }
}

impl SelectionStrategy {
    pub fn vec_subprotocol(subprotocol: SubProtocol) -> Vec<SelectionStrategy> {
        match subprotocol {
            SubProtocol::History => HistorySelectionStrategy::iter()
                .map(SelectionStrategy::History)
                .collect(),
            SubProtocol::State => StateSelectionStrategy::iter()
                .map(SelectionStrategy::State)
                .collect(),
            SubProtocol::Beacon => BeaconSelectionStrategy::iter()
                .map(SelectionStrategy::Beacon)
                .collect(),
        }
    }
}

impl Model {
    pub fn is_success(&self) -> bool {
        self.result == AuditResult::Success
    }
    pub fn created_at_local_time(&self) -> String {
        self.created_at.with_timezone(&chrono::Local).to_rfc2822()
    }
    pub fn created_at_humanized(&self) -> String {
        utils::time_ago(self.created_at, Utc::now())
    }
    /// A convenience method for displaying the strategy.
    ///
    /// A few early database entries do not have a recorded strategy.
    pub fn strategy_as_text(&self) -> String {
        match &self.strategy_used {
            Some(s) => s.to_string(),
            None => "No strategy recorded".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use sea_orm::{ActiveEnum, Value};

    use super::{
        BeaconSelectionStrategy, HistorySelectionStrategy, SelectionStrategy,
        StateSelectionStrategy,
    };

    #[test]
    fn test_selection_strategy_to_value() {
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::Latest).to_value(),
            0
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::Random).to_value(),
            1
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::Failed).to_value(),
            2
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::OldestUnaudited).to_value(),
            3
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::SpecificContentKey).to_value(),
            4
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::FourFours).to_value(),
            5
        );
        assert_eq!(
            SelectionStrategy::Beacon(BeaconSelectionStrategy::Latest).to_value(),
            0x10000
        );
        assert_eq!(
            SelectionStrategy::State(StateSelectionStrategy::StateRoots).to_value(),
            0x20000
        );
    }

    #[test]
    fn test_selection_strategy_try_from_value() {
        assert_eq!(
            SelectionStrategy::try_from_value(&0).unwrap(),
            SelectionStrategy::History(HistorySelectionStrategy::Latest)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&1).unwrap(),
            SelectionStrategy::History(HistorySelectionStrategy::Random)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&2).unwrap(),
            SelectionStrategy::History(HistorySelectionStrategy::Failed)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&3).unwrap(),
            SelectionStrategy::History(HistorySelectionStrategy::OldestUnaudited)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&4).unwrap(),
            SelectionStrategy::History(HistorySelectionStrategy::SpecificContentKey)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&5).unwrap(),
            SelectionStrategy::History(HistorySelectionStrategy::FourFours)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&0x10000).unwrap(),
            SelectionStrategy::Beacon(BeaconSelectionStrategy::Latest)
        );
        assert_eq!(
            SelectionStrategy::try_from_value(&0x20000).unwrap(),
            SelectionStrategy::State(StateSelectionStrategy::StateRoots)
        );
    }

    #[test]
    fn test_selection_strategy_to_string() {
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::Latest).to_string(),
            "Latest"
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::Random).to_string(),
            "Random"
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::Failed).to_string(),
            "Failed"
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::OldestUnaudited).to_string(),
            "Oldest Unaudited"
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::SpecificContentKey).to_string(),
            "Specific Content Key"
        );
        assert_eq!(
            SelectionStrategy::History(HistorySelectionStrategy::FourFours).to_string(),
            "Four Fours"
        );
        assert_eq!(
            SelectionStrategy::Beacon(BeaconSelectionStrategy::Latest).to_string(),
            "Latest"
        );
        assert_eq!(
            SelectionStrategy::State(StateSelectionStrategy::StateRoots).to_string(),
            "State Roots"
        );
    }

    #[test]
    fn test_selection_strategy_from_text() {
        assert_eq!(
            HistorySelectionStrategy::try_from("Latest").unwrap(),
            HistorySelectionStrategy::Latest,
        );
        assert_eq!(
            HistorySelectionStrategy::try_from("latest").unwrap(),
            HistorySelectionStrategy::Latest,
        );
        assert_eq!(
            HistorySelectionStrategy::try_from("random").unwrap(),
            HistorySelectionStrategy::Random,
        );
        assert_eq!(
            HistorySelectionStrategy::try_from("failed").unwrap(),
            HistorySelectionStrategy::Failed
        );
        assert_eq!(
            HistorySelectionStrategy::try_from("oldest_unaudited").unwrap(),
            HistorySelectionStrategy::OldestUnaudited
        );
        assert_eq!(
            HistorySelectionStrategy::try_from("specific_content_key").unwrap(),
            HistorySelectionStrategy::SpecificContentKey
        );
        assert_eq!(
            HistorySelectionStrategy::try_from("four_fours").unwrap(),
            HistorySelectionStrategy::FourFours
        );
        assert_eq!(
            BeaconSelectionStrategy::try_from("latest").unwrap(),
            BeaconSelectionStrategy::Latest
        );
        assert_eq!(
            StateSelectionStrategy::try_from("state_roots").unwrap(),
            StateSelectionStrategy::StateRoots
        );
    }

    #[test]
    fn test_from_selection_strategy_to_value() {
        assert_eq!(
            Value::from(SelectionStrategy::History(HistorySelectionStrategy::Latest)),
            Value::Int(Some(0))
        );
        assert_eq!(
            Value::from(SelectionStrategy::History(HistorySelectionStrategy::Random)),
            Value::Int(Some(1))
        );
        assert_eq!(
            Value::from(SelectionStrategy::History(HistorySelectionStrategy::Failed)),
            Value::Int(Some(2))
        );
        assert_eq!(
            Value::from(SelectionStrategy::History(
                HistorySelectionStrategy::OldestUnaudited
            )),
            Value::Int(Some(3))
        );
        assert_eq!(
            Value::from(SelectionStrategy::History(
                HistorySelectionStrategy::SpecificContentKey
            )),
            Value::Int(Some(4))
        );
        assert_eq!(
            Value::from(SelectionStrategy::History(
                HistorySelectionStrategy::FourFours
            )),
            Value::Int(Some(5))
        );
        assert_eq!(
            Value::from(SelectionStrategy::Beacon(BeaconSelectionStrategy::Latest)),
            Value::Int(Some(0x10000))
        );
        assert_eq!(
            Value::from(SelectionStrategy::State(StateSelectionStrategy::StateRoots)),
            Value::Int(Some(0x20000))
        );
    }
}
