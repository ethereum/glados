//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.13

use alloy_primitives::B256;
use ethportal_api::{
    utils::bytes::{hex_encode, hex_encode_compact},
    OverlayContentKey,
};
use sea_orm::{entity::prelude::*, NotSet, Set};

use crate::{ContentType, SubProtocol};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "content")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub sub_protocol: SubProtocol,
    #[sea_orm(column_type = "VarBinary(StringLen::N(32))")]
    pub content_id: Vec<u8>,
    #[sea_orm(column_type = "VarBinary(StringLen::None)")]
    pub content_key: Vec<u8>,
    pub content_type: ContentType,
    pub block_number: Option<i64>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::audit::Entity")]
    Audit,
    #[sea_orm(has_one = "super::audit_latest::Entity")]
    AuditLatest,
}

impl Related<super::audit::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Audit.def()
    }
}

impl Related<super::audit_latest::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::AuditLatest.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

// *** Custom additions ***

pub async fn get_or_create<T: OverlayContentKey + AsRef<ContentType>>(
    sub_protocol: SubProtocol,
    content_key: &T,
    block_number: Option<u64>,
    conn: &DatabaseConnection,
) -> Result<Model, DbErr> {
    // First try to lookup an existing entry.
    if let Some(content_key_model) = Entity::find()
        .filter(Column::SubProtocol.eq(sub_protocol))
        .filter(Column::ContentKey.eq(content_key.to_bytes().as_ref()))
        .one(conn)
        .await?
    {
        // If there is an existing record, return it
        return Ok(content_key_model);
    }

    // If no record exists, create one and return it
    let content = ActiveModel {
        id: NotSet,
        sub_protocol: Set(sub_protocol),
        content_id: Set(content_key.content_id().to_vec()),
        content_key: Set(content_key.to_bytes().to_vec()),
        content_type: Set(*content_key.as_ref()),
        block_number: Set(block_number.map(|block_number| block_number as i64)),
    };
    content.insert(conn).await
}

pub async fn get<T: OverlayContentKey>(
    content_key: &T,
    conn: &DatabaseConnection,
) -> Result<Option<Model>, DbErr> {
    Entity::find()
        .filter(Column::ContentKey.eq(content_key.to_bytes().as_ref()))
        .one(conn)
        .await
}

/// These are helper functions for glados-web.
impl Model {
    pub fn id_as_hash(&self) -> B256 {
        B256::from_slice(&self.content_id)
    }

    pub fn id_as_hex(&self) -> String {
        hex_encode(&self.content_id)
    }

    pub fn id_as_hex_short(&self) -> String {
        hex_encode_compact(&self.content_id)
    }

    pub fn key_as_hash(&self) -> B256 {
        B256::from_slice(&self.content_key)
    }

    pub fn key_as_hex(&self) -> String {
        hex_encode(&self.content_key)
    }

    pub fn key_as_hex_short(&self) -> String {
        hex_encode_compact(&self.content_key)
    }

    pub fn block_number(&self) -> Option<u64> {
        self.block_number.map(|block_number| block_number as u64)
    }
}

#[cfg(test)]
mod tests {
    use ethportal_api::HistoryContentKey;

    use crate::test_utils::setup_database;

    use super::*;

    /// Returns a history content key representing the header with proof
    /// for block hash `0x0001...1e1f`
    fn history_content() -> (HistoryContentKey, u64) {
        let block_number = 12_345_678;
        (
            HistoryContentKey::new_block_header_by_number(block_number),
            block_number,
        )
    }

    /// Tests that the database helper method id_as_hash() works.
    #[tokio::test]
    async fn content_id_as_hash() -> Result<(), DbErr> {
        let (conn, _db) = setup_database().await?;
        let (key, block_number) = history_content();
        let content_model = get_or_create(SubProtocol::History, &key, Some(block_number), &conn)
            .await
            .unwrap();
        assert_eq!(content_model.id_as_hash(), B256::from(key.content_id()));
        Ok(())
    }

    /// Tests that the database helper method id_as_hex() works.
    #[tokio::test]
    async fn content_id_as_hex() -> Result<(), DbErr> {
        let (conn, _db) = setup_database().await?;
        let (key, block_number) = history_content();
        let content_id_hash = B256::from(key.content_id());

        let content_model = get_or_create(SubProtocol::History, &key, Some(block_number), &conn)
            .await
            .unwrap();
        assert_eq!(content_model.id_as_hex(), content_id_hash.to_string());
        Ok(())
    }

    /// Tests that the database helper method key_as_hex() works.
    #[tokio::test]
    async fn content_key_as_hex() -> Result<(), DbErr> {
        let (conn, _db) = setup_database().await?;
        let (key, block_number) = history_content();
        let content_model = get_or_create(SubProtocol::History, &key, Some(block_number), &conn)
            .await
            .unwrap();
        assert_eq!(content_model.key_as_hex(), key.to_hex());
        Ok(())
    }

    /// Tests that the get_or_create() function correctly handles the
    /// presence or absence of a key in the database.
    #[tokio::test]
    async fn content_get_or_create() -> Result<(), DbErr> {
        let (conn, _db) = setup_database().await?;
        let (key, block_number) = history_content();

        // Ensure our database is empty
        assert_eq!(Entity::find().count(&conn).await?, 0);

        let content_id_a = get_or_create(SubProtocol::History, &key, Some(block_number), &conn)
            .await
            .unwrap();

        // Ensure we added a new record to the database.
        assert_eq!(Entity::find().count(&conn).await?, 1);

        // Retrieve the key
        let content_id_b = get_or_create(SubProtocol::History, &key, Some(block_number), &conn)
            .await
            .unwrap();

        // Key was not saved twice.
        assert_eq!(Entity::find().count(&conn).await?, 1);

        // Ensure that get_or_create found the existing entry.
        assert_eq!(content_id_a.id, content_id_b.id);
        assert_eq!(content_id_a.content_key, content_id_b.content_key);
        Ok(())
    }

    /// Tests that the content table unique constraints prevent duplicate entries.
    ///
    /// No two keys should have the same protocol_id, content_key and content_id combination.
    /// Note: we can't test different protocol_id as we currently only support one.
    #[tokio::test]
    async fn content_table_unique_constraints() {
        let (conn, _db) = setup_database().await.unwrap();
        let id_a = vec![1; 32];
        let id_b = vec![2; 32];
        let key_a = vec![3; 32];
        let key_b = vec![4; 32];
        let key_c = vec![5; 32];
        let sub_protocol = SubProtocol::History;
        // DB=0. Add one key (accepts). DB==1.
        let action_a = ActiveModel {
            id: NotSet,
            sub_protocol: Set(sub_protocol),
            content_id: Set(id_a.clone()),
            content_key: Set(key_a.clone()),
            content_type: Set(ContentType::BlockBodies),
            block_number: NotSet,
        };
        action_a.clone().insert(&conn).await.unwrap();
        assert_eq!(Entity::find().count(&conn).await.unwrap(), 1);

        // DB=1. Repeat addition (rejects). DB=1.
        assert!(action_a
            .insert(&conn)
            .await
            .unwrap_err()
            .to_string()
            .contains("violates unique constraint"));

        assert_eq!(Entity::find().count(&conn).await.unwrap(), 1);

        // DB=1. Add different content_key, different content_id, same protocol (accepts). DB=2.
        let action_b = ActiveModel {
            id: NotSet,
            sub_protocol: Set(sub_protocol),
            content_id: Set(id_b.clone()),
            content_key: Set(key_b.clone()),
            content_type: Set(ContentType::BlockBodies),
            block_number: NotSet,
        };
        action_b.clone().insert(&conn).await.unwrap();
        assert_eq!(Entity::find().count(&conn).await.unwrap(), 2);

        // DB=2. Repeat addition (rejects). DB=2.
        assert!(action_b
            .insert(&conn)
            .await
            .unwrap_err()
            .to_string()
            .contains("violates unique constraint"));
        assert_eq!(Entity::find().count(&conn).await.unwrap(), 2);

        // DB=2. Add different content_key, same content_id, same protocol (accepts). DB=3.
        let action_c = ActiveModel {
            id: NotSet,
            sub_protocol: Set(sub_protocol),
            content_id: Set(id_a),
            content_key: Set(key_c),
            content_type: Set(ContentType::BlockBodies),
            block_number: NotSet,
        };
        action_c.insert(&conn).await.unwrap();
        assert_eq!(Entity::find().count(&conn).await.unwrap(), 3);
    }
}
